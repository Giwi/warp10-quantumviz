<link rel="import" href=" ../polymer/polymer.html">
<link   rel="import" href="../warp10-quantumviz/warp10-quantumviz.html">
<script src="../Leaflet.MakiMarkers/Leaflet.MakiMarkers.js"></script>
<dom-module name="warp10-geoquantumviz" >
  <style>
    :host {
      display: block;
    }
  	leaflet-map {
      max-width: 100%;
      width: 100%;
      height: 400px;
      border: 1px solid #aaa;
  	}
    /deep/ .leaflet-control-attribution {
      display: none;
    }
    #map-spinner {
      z-index: 1000;
    }
  </style>
  <template>

    <spinner-widget id="map-spinner" active="{{loading}}" hover container-height="{{mapHeight}}" size="{{_mapSpinnerSize}}" ></spinner-widget>
    <leaflet-map id="map" latitude="{{mapLat}}" longitude="{{mapLon}}" zoom="{{mapZoom}}">
    </leaflet-map>

    <warp10-quantumviz
      width="{{width}}" height="{{height}}"
      show-axis="{{showAxis}}"  tooltip="{{tooltip}}"
      line-width="{{lineWidth}}" reload="{{reload}}"
      current-values="{{currentValues}}" host="{{host}}"
      content="{{_warpScript}}" data="{{data}}" old-path="{{oldPath}}"
      loading="{{loading}}"
      >
    </warp10-quantumviz>

  </template>
</dom-module>

  <script>
    // element registration
    Polymer({
      is: "warp10-geoquantumviz",
      properties: {
          mapWidth: {
            type: Number,
            value: -1
          },
          mapHeight: {
            type: Number,
            value: -1
          },
          mapZoom: {
            type: Number,
            value: 0
          },
          mapLon: {
            type: Number,
            value: 0
          },
          mapLat: {
            type: Number,
            value: 0
          },
          host: {
            type: String,
            value: ""
          },
          showAxis: {
            type: String,
            value: "true"
          },
          tooltip: {
            type: String,
            value: "true"
          },
          lineWidth: {
            type: Number,
            value: 2
          },
          reload: {
            type: Number,
            value: -1
          },
          currentValues: {
            type: Object,
            observer: 'currentValuesChanged',
            notify: true
          },
          data: {
            type: Object,
            observer: 'dataChanged',
            notify: true
          },
          oldPath: {
            type: String,
            value: ""
          },
          _mapSpinnerSize: {
            type: Number,
            computed: "_getMapSpinnerSize(mapHeight)"
          },
          _warpScript: {
            type: String,
            computed: "_getWarpScript(content)"
          }
      },
      ready: function() {
        this.content = Polymer.dom(this).innerHTML.replace(/&lt;/g,'<').replace(/&gt;/g,'>');
        this.polylinesBeforeCurrentValue = [];
        this.polylinesAfterCurrentValue = [];
        this.currentValuesMarkers = [];

        // Dimensions
        if (this.mapWidth > 0) {
          this.$.map.style.width = this.mapWidth+"px";
          this.$.map.style.maxWidth = this.mapWidth+"px";
        }
        if (this.mapHeight > 0) {
          this.$.map.style.height = this.mapHeight+"px";
        }
        console.debug("[warp10-geoquantumviz] Dimensions", this.$.map.style);
      },
      _getMapSpinnerSize: function() {
        console.debug("[warp10-geoquantumviz] _getMapSpinnerSize called", Math.floor(this.mapHeight * 0.75))
        return Math.floor(this.mapHeight * 0.75);
      },
      _getWarpScript: function() {
        // Setting lat, lon and zoom as script variables
        var warpscript = "";
        warpscript += this.mapLat +" 'lat' STORE ";
        warpscript += this.mapLon +" 'lon' STORE ";
        warpscript += this.mapZoom +" 'zoom' STORE ";
        return warpscript += this.content;
      },
      _plotPositionArray: function(positionData, map) {
        console.debug('[warp10-geoquantumviz] _plotPositionArray - item', positionData);
        switch (positionData.render) {
          case 'path':
            L.polyline(positionData.positions, {color: positionData.color, opacity: 1} ).addTo(map);
            break;
          case 'marker':
            var icon = L.MakiMarkers.icon({icon: positionData.key, color: positionData.color, size: "m"});
            for (var j=0; j<positionData.positions.length; j++ ) {
              L.marker(positionData.positions[j], {icon: icon, opacity: 1} ).addTo(map);
            }
            break;
          case 'weightedDots':
            for (var j=0; j<positionData.positions.length; j++ ) {
              L.circleMarker(
                positionData.positions[j],{
                  radius: positionData.baseRadius*positionData.positions[j][3],
                  color:  positionData.borderColor,
                  fillColor:
                  positionData.color, fillOpacity: 1
                }).addTo(map);
            }
            break;
          case 'dots':
          default:
            for (var j=0; j<positionData.positions.length; j++ ) {
              L.circleMarker(
                positionData.positions[j],{
                  radius: 10,
                  color: positionData.borderColor,
                  fillColor: positionData.color,
                  fillOpacity: 1
                }
              ).addTo(map);
            }
            break;
        }


      },
      dataChanged: function() {


        this.pathData = quantumvizGts.toLeafletMapPaths(this.data);
        this.positionsData = quantumvizGts.toLeafletMapPositionArray(this.data);
        console.debug("[warp10-geoquantumviz] Data changed - path data", this.pathData);
        console.debug("[warp10-geoquantumviz] Data changed - position arrays", this.positionsData);

        var map = this.$.map.map


        var circleRadius = map.getBounds().getSouthWest().distanceTo(map.getBounds().getNorthEast())/30;
        // Create the polylines and the circle marker
        for (var i=0; i< this.pathData.length; i++) {
          this.polylinesBeforeCurrentValue.push(L.polyline(quantumvizGts.pathDataToLeaflet(this.pathData[i].path, {to:0}), {color: this.pathData[i].color, opacity: 1} ).addTo(map));
          this.polylinesAfterCurrentValue.push(L.polyline(quantumvizGts.pathDataToLeaflet(this.pathData[i].path, {from:0}), {color: this.pathData[i].color, opacity: 0.5} ).addTo(map));

          //Let's verify we have a path... No path, no marker
          if (this.pathData[i].path[0] !== undefined ) {
            var circle = L.circleMarker([this.pathData[i].path[0].lat, this.pathData[i].path[0].lon],
              {radius: 5, color:  "#fff", fillColor:  this.pathData[i].color, fillOpacity: 1}).addTo(map);
            this.currentValuesMarkers.push(circle);
          } else {
            this.currentValuesMarkers.push(L.circleMarker());
          }
        }

        // Create the positions arrays
        for (var i=0; i< this.positionsData.length; i++) {
          this._plotPositionArray(this.positionsData[i], map);
        }

        // Fit map to curves
        map.fitBounds(quantumvizGts.getBoundsArray(this.pathData,this.positionsData));

      },
      currentValuesChanged: function() {
        var map = this.$.map.map
        // All works on seconds only now...
        //console.log("Current time "+ this.currentValues.xValue + " - "+ new Date(this.currentValues.xValue) + " - " + (new Date(this.currentValues.xValue)).getTime() )
        var currentTS = Math.floor( (new Date(this.currentValues.xValue)).getTime() / 1000 );

        for (var i=0; i< this.pathData.length; i++) {
          for (var j=0; j<this.pathData[i].path.length; j++) {
            //console.log("Do they match? "+currentTS+ " - "+this.pathData[i].path[j].ts)
            if (currentTS <= Math.floor( this.pathData[i].path[j].ts / 1000 )) {
              this.currentValuesMarkers[i].setLatLng([this.pathData[i].path[j].lat, this.pathData[i].path[j].lon]);
              this.polylinesBeforeCurrentValue[i].setLatLngs(quantumvizGts.pathDataToLeaflet(this.pathData[i].path, {to:j}));
              this.polylinesAfterCurrentValue[i].setLatLngs(quantumvizGts.pathDataToLeaflet(this.pathData[i].path, {from:j}));
              break;
            }
          }
        }
      }
    });
  </script>
