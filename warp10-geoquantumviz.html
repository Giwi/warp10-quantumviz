<link rel="import" href=" ../polymer/polymer.html">
<link   rel="import" href="../warp10-quantumviz/warp10-quantumviz.html">
<script src="../Leaflet.MakiMarkers/Leaflet.MakiMarkers.js"></script>
<dom-module name="warp10-geoquantumviz" >
  <style>
    :host {
      display: block;
    }
  	leaflet-map {
      max-width: 100%;
      width: 100%;
      height: 400px;
      border: 1px solid #aaa;
  	}
    /deep/ .leaflet-control-attribution {
      display: none;
    }
    #map-spinner {
      z-index: 1000;
    }
  </style>
  <template>

    <spinner-widget id="map-spinner" active="{{loading}}" hover container-height="{{mapHeight}}" size="{{_mapSpinnerSize}}" ></spinner-widget>
    <leaflet-map id="map" latitude="{{mapLat}}" longitude="{{mapLon}}" zoom="{{mapZoom}}">
    </leaflet-map>

    <warp10-quantumviz
      width="{{width}}" height="{{height}}"
      show-axis="{{showAxis}}"  tooltip="{{tooltip}}"
      line-width="{{lineWidth}}" reload="{{reload}}"
      current-values="{{currentValues}}" host="{{host}}"
      content="{{_warpScript}}" data="{{data}}" old-path="{{oldPath}}"
      loading="{{loading}}" annotations-selected-timestamp="{{annotationsSelectedTimestamp}}"
      >
    </warp10-quantumviz>

  </template>
</dom-module>

  <script>
    // element registration
    Polymer({
      is: "warp10-geoquantumviz",
      properties: {
        /**
         * The chart width, in pixels
         */
        width: {
          type: Number,
          value: -1
        },
        /**
         * The chart height, in pixels
         */
        height: {
          type: Number,
          value: -1
        },
        /**
         * The data of the chart
         */
        data: {
          type: Object,
          notify: true,
          observer: "dataChanged"
        },
        /**
         * The Warp 10 instance
         */
        host: {
          type: String,
          value: ""
        },
        /**
        * The width of the lines on the chart
        * It must be a number between warp10-display-chart's _MIN_LINE_WIDTH and _MAX_LINE_WIDTH
        */
        lineWidth: {
          type: Number,
          value: 2
        },
        /**
         * If true, axis aren't shown
         */
        hideAxis: {
          type: Boolean,
          value: false
        },
        /**
         * If true, tooltip isn't shown
         */
        hideTooltip: {
          type: Boolean,
          value: false
        },
        /**
         * If true, legend isn't shown
         */
        hideLegend: {
          type: Boolean,
          value: false
        },
          mapWidth: {
            type: Number,
            value: -1
          },
          mapHeight: {
            type: Number,
            value: -1
          },
          mapZoom: {
            type: Number,
            value: 0
          },
          mapLon: {
            type: Number,
            value: 0
          },
          mapLat: {
            type: Number,
            value: 0
          },
          reload: {
            type: Number,
            value: -1
          },
          currentValues: {
            type: Object,
            observer: 'currentValuesChanged',
            notify: true
          },
          oldPath: {
            type: String,
            value: ""
          },
          _mapSpinnerSize: {
            type: Number,
            computed: "_getMapSpinnerSize(mapHeight)"
          },
          _warpScript: {
            type: String,
            computed: "_getWarpScript(content)"
          },
          annotationsSelectedTimestamp: {
            type: Number,
            notify: true,
            observer: "_annotationsSelectedTimestampChanged",
            value: -1
          }
      },
      created: function(){
        this.polylinesBeforeCurrentValue = [];
        this.polylinesAfterCurrentValue = [];
        this.currentValuesMarkers = [];
        this.annotationsMarkers = [];
      },
      ready: function() {
        this.content = Polymer.dom(this).innerHTML.replace(/&lt;/g,'<').replace(/&gt;/g,'>');

        // Dimensions
        if (this.mapWidth > 0) {
          this.$.map.style.width = this.mapWidth+"px";
          this.$.map.style.maxWidth = this.mapWidth+"px";
        }
        if (this.mapHeight > 0) {
          this.$.map.style.height = this.mapHeight+"px";
        }
        console.debug("[warp10-geoquantumviz] Dimensions", this.$.map.style);
      },
      _annotationsSelectedTimestampChanged: function() {
        // console.debug("[warp10-geoquantumviz] _annotationsSelectedTimestampChanged", this.annotationsSelectedTimestamp);
        for (var i=0; i < this.annotationsMarkers.length; i++) {
          for (var tick=0; tick < this.annotationsMarkers[i].length; tick++) {
            //console.debug("[warp10-geoquantumviz] _annotationsSelectedTimestampChanged - this.annotationsMarkers[i][tick].options.timestamp",     this.annotationsMarkers[i][tick].options.timestamp);
            // We divide by 10 because d3.x precision problem
            if (Math.floor(this.annotationsMarkers[i][tick].options.timestamp/10) == Math.floor(this.annotationsSelectedTimestamp/10)) {
              // console.debug("[warp10-geoquantumviz] _annotationsSelectedTimestampChanged - found", this.annotationsMarkers[i][tick]);
              this.annotationsMarkers[i][tick].options.oldStyle = this.annotationsMarkers[i][tick].options.fillColor;
              this.annotationsMarkers[i][tick].setStyle({fillColor: 'orange'});
            } else {
              if (this.annotationsMarkers[i][tick].options.oldStyle) {
                  this.annotationsMarkers[i][tick].setStyle({
                    fillColor: this.annotationsMarkers[i][tick].options.oldStyle
                  });
                  this.annotationsMarkers[i][tick].options.oldStyle = null;
              }
            }
          }
        }
      },
      _getMapSpinnerSize: function() {
        console.debug("[warp10-geoquantumviz] _getMapSpinnerSize called", Math.floor(this.mapHeight * 0.75))
        return Math.floor(this.mapHeight * 0.75);
      },
      _getWarpScript: function() {
        // Setting lat, lon and zoom as script variables
        var warpscript = "";
        warpscript += this.mapLat +" 'lat' STORE ";
        warpscript += this.mapLon +" 'lon' STORE ";
        warpscript += this.mapZoom +" 'zoom' STORE ";
        return warpscript += this.content;
      },
      _plotPositionArray: function(positionData, map) {
        // console.debug('[warp10-geoquantumviz] _plotPositionArray - item', positionData);
        switch (positionData.render) {
          case 'path':
            L.polyline(positionData.positions, {color: positionData.color, opacity: 1} ).addTo(map);
            break;
          case 'marker':
            var icon = L.MakiMarkers.icon({icon: positionData.key, color: positionData.color, size: "m"});
            for (var j=0; j<positionData.positions.length; j++ ) {
              L.marker(positionData.positions[j], {icon: icon, opacity: 1} ).addTo(map);
            }
            break;
          case 'coloredWeightedDots':
            var result = []
            var prix = [],
              inStep = [];
            for (var j=0;j<positionData.numColorSteps; j++){
              result[j] = 0;
              inStep[j] = 0;
            }
            for (var j=0; j<positionData.positions.length; j++ ) {
              // console.debug('[warp10-geoquantumviz] _plotPositionArray, coloredWeightedDots', { j: j, gradient: positionData.colorGradient, position: positionData.positions[j]})
              L.circleMarker(
                positionData.positions[j],{
                  radius: positionData.baseRadius*(parseInt(positionData.positions[j][4])+1),
                  color:  positionData.borderColor,
                  fillColor: quantumvizGts.rgb2hex(
                    positionData.colorGradient[positionData.positions[j][5]].r,
                    positionData.colorGradient[positionData.positions[j][5]].g,
                    positionData.colorGradient[positionData.positions[j][5]].b),
                  fillOpacity: 1
                }).addTo(map);
            }
            break;
          case 'weightedDots':
            for (var j=0; j<positionData.positions.length; j++ ) {
              L.circleMarker(
                positionData.positions[j],{
                  radius:positionData.baseRadius*(parseInt(positionData.positions[j][4])+1),
                  color:  positionData.borderColor,
                  fillColor: positionData.color, fillOpacity: 1
                }).addTo(map);
            }
            break;
          case 'dots':
          default:
            for (var j=0; j<positionData.positions.length; j++ ) {
              L.circleMarker(
                positionData.positions[j],{
                  radius: positionData.baseRadius,
                  color: positionData.borderColor,
                  fillColor: positionData.color,
                  fillOpacity: 1
                }
              ).addTo(map);
            }
            break;
        }
      },
      _plotGts(gts, map) {
        var beforeCurrentValue =
          L.polyline(
            quantumvizGts.pathDataToLeaflet(gts.path, {to:0}), {
              color: gts.color,
              opacity: 1
            }
          ).addTo(map);
        var afterCurrentValue = L.polyline(
          quantumvizGts.pathDataToLeaflet(gts.path, {from:0}), {
            color: gts.color,
            opacity: 0.5
          }
        ).addTo(map);
        // this.polylinesBeforeCurrentValue.push(beforeCurrentValue);
        // this.polylinesAfterCurrentValue.push(afterCurrentValue);

        var currentValue;
        //Let's verify we have a path... No path, no marker
        if (gts.path[0] !== undefined ) {
          currentValue = L.circleMarker([gts.path[0].lat, gts.path[0].lon],
            {radius: 5, color:  "#fff", fillColor:  gts.color, fillOpacity: 1}).addTo(map);
        } else {
          currentValue = L.circleMarker();
        }
        // this.currentValuesMarkers.push(currentValue);
        return {
          beforeCurrentValue: beforeCurrentValue,
          afterCurrentValue: afterCurrentValue,
          currentValue: currentValue
        }
      },
      _plotAnnotation(gts, map) {
        var positions = [];

        switch (gts.render) {
          case 'marker':
            var icon = L.MakiMarkers.icon({icon: gts.marker, color: gts.color, size: "m"});
            for (var j=0; j<gts.path.length; j++ ) {
              var marker = L.marker(gts.path[j], {icon: icon, opacity: 1} ).addTo(map);
              marker.bindPopup(gts.path[j].val.toString());
                positions.push(marker);
            }
            break;
          case 'dots':
          default:
            for (var j=0; j<gts.path.length; j++ ) {
              var marker = L.circleMarker(
                gts.path[j],{
                  radius: 10,
                  color: gts.color,
                  fillColor: gts.color,
                  fillOpacity: 1,
                  timestamp: gts.path[j].ts
                }
              ).addTo(map);
              marker.bindPopup(gts.path[j].val.toString());
              // console.debug("[warp10-geoquantumviz] _plotAnnotation - gts", gts);
              positions.push(marker);
            }
            break;
        }
        return positions;
      },
      dataChanged: function() {
        this.pathData = quantumvizGts.toLeafletMapPaths(this.data);
        this.annotationsData = quantumvizGts.annotationsToLeafletPositions(this.data);
        this.positionsData = quantumvizGts.toLeafletMapPositionArray(this.data);
        console.debug("[warp10-geoquantumviz] Data changed - path data", this.pathData);
        console.debug("[warp10-geoquantumviz] Data changed - position arrays", this.positionsData);

        var map = this.$.map.map


        var circleRadius = map.getBounds().getSouthWest().distanceTo(map.getBounds().getNorthEast())/30;
        // Create the polylines and the circle marker
        for (var i=0; i< this.pathData.length; i++) {
          var plottedGts = this._plotGts(this.pathData[i], map);
          this.polylinesBeforeCurrentValue.push(plottedGts.beforeCurrentValue);
          this.polylinesAfterCurrentValue.push(plottedGts.afterCurrentValue);
          this.currentValuesMarkers.push(plottedGts.currentValue);
        }

        for (var i=0; i< this.annotationsData.length; i++) {
          this.annotationsMarkers.push(this._plotAnnotation(this.annotationsData[i], map));
        }

        // Create the positions arrays
        for (var i=0; i< this.positionsData.length; i++) {
          this._plotPositionArray(this.positionsData[i], map);
        }

        // Fit map to curves
        map.fitBounds(quantumvizGts.getBoundsArray(this.pathData,this.positionsData));

      },
      currentValuesChanged: function() {
        var map = this.$.map.map
        // All works on seconds only now...
        //console.log("Current time "+ this.currentValues.xValue + " - "+ new Date(this.currentValues.xValue) + " - " + (new Date(this.currentValues.xValue)).getTime() )
        var currentTS = Math.floor( (new Date(this.currentValues.xValue)).getTime() / 1000 );

        for (var i=0; i< this.pathData.length; i++) {
          for (var j=0; j<this.pathData[i].path.length; j++) {
            //console.log("Do they match? "+currentTS+ " - "+this.pathData[i].path[j].ts)
            if (currentTS <= Math.floor( this.pathData[i].path[j].ts / 1000 )) {
              this.currentValuesMarkers[i].setLatLng([this.pathData[i].path[j].lat, this.pathData[i].path[j].lon]);
              this.polylinesBeforeCurrentValue[i].setLatLngs(quantumvizGts.pathDataToLeaflet(this.pathData[i].path, {to:j}));
              this.polylinesAfterCurrentValue[i].setLatLngs(quantumvizGts.pathDataToLeaflet(this.pathData[i].path, {from:j}));
              break;
            }
          }
        }
      }
    });
  </script>
