<link rel="import" href="../warp10-iron/warp10-gts-tools.html">

<script>
(function() {
  var quantumvizGts = {};

  /***********************************************************************************
  * Quantumviw response format
  *
  *  {
  *    gts: [ `gts_list` ],          // a LIST of GTS to plot
  *    params: [ `parameter` ],      // a LIST of visualisation parameters for each GTS to plot
  *    globalParams                  // (optional)  a MAP of global visualisations parameters
  *  }
  *
  *  where each `parameter` in `params` or `annotationsParams` is:
  *  {
  *    key,                          // the legend to associate to the GTS
  *    color                         // (optional) the color of the line,
  *                                  //  as an CSS compliant color STRING (e.g.: #cc0505)
  *  }
  * and `globalParams` is :
  *  {
  *    interpolate                   // the interpolating function used. Default mode is
  *                                  // `step-before`, other usual modes are `linear`, `basis`
  *                                  // and `cardinal`
  *  }
  ***********************************************************************************/

  /***********************************************************************************
  * Constants
  ***********************************************************************************/
  quantumvizGts.BASE_RADIUS = 10;
  quantumvizGts.MIN_TS = 0;
  quantumvizGts.MAX_TS = Math.pow(2, 53) - 1;
  quantumvizGts.palette = [
    '#001f3f', // NAVY
    '#0074D9', // BLUE
    '#7FDBFF', // AQUA
    '#39CCCC', // TEAL
    '#3D9970', // OLIVE
    '#2ECC40', // GREEN
    '#01FF70', // LIME
    '#FFDC00', // YELLOW
    '#FF851B', // ORANGE
    '#FF4136', // RED
    '#85144b', // MAROON
    '#F012BE', // FUSCHIA
    '#B10DC9', // PURPLE
    '#111111', // BLACK
    '#AAAAAA', // GRAY
    '#DDDDDD' // SILVER
  ]

  /***********************************************************************************
  * Getting color from palette
  ***********************************************************************************/
  quantumvizGts.getColor = function(i) {
    return quantumvizGts.palette[i % quantumvizGts.palette.length];
  }

  quantumvizGts.rgb2hex = function(r,g,b) {

    function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    }

    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);

  }


  /***********************************************************************************
  * Converts an HSV color value to RGB. Conversion formula
  * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
  * Assumes h, s, and v are contained in the set [0, 1] and
  * returns r, g, and b in the set [0, 255].
  *
  * @param   Number  h       The hue
  * @param   Number  s       The saturation
  * @param   Number  v       The value
  * @return  Array           The RGB representation
  ***********************************************************************************/
  quantumvizGts.hsv2rgb = function (h,s,v) {
        var r, g, b;

        var i = Math.floor(h * 6);
        var f = h * 6 - i;
        var p = v * (1 - s);
        var q = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);

        switch(i % 6){
            case 0: r = v, g = t, b = p; break;
            case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break;
            case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break;
            case 5: r = v, g = p, b = q; break;
        }

        return [r * 255, g * 255, b * 255];
  }


  /***********************************************************************************
  * Converts an RGB color value to HSV. Conversion formula
  * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
  * Assumes r, g, and b are contained in the set [0, 255] and
  * returns h, s, and v in the set [0, 1].
  *
  * @param   Number  r       The red color value
  * @param   Number  g       The green color value
  * @param   Number  b       The blue color value
  * @return  Array           The HSV representation
  ***********************************************************************************/
  quantumvizGts.rgb2hsv = function (r,g,b) {
    // console.debug("[quantumviz-tools] rgb2hsv - RGB", [r,g,b]);
    // Normalize
    var normR = r/255.0,
    normG = g/255.0,
    normB = b/255.0


    var M = Math.max(normR, normG, normB);
    var m = Math.min(normR, normG, normB);
    var d = M - m;

    var h,s,v;

    v = M;
    if (d==0) {
      h = 0;
      s = 0;
    } else {
      s = d/v
      switch (M) {
        case normR:
        h = ((normG - normB) + d*(normG < normB ? 6: 0)) / 6 * d;
        break;
        case normG:
        h = ((normB - normR) + d*2) / 6 * d;
        break;
        case normB:
        h = ((normR - normG) + d*4) / 6 * d;
        break;
      }
    }

    // console.debug("[quantumviz-tools] rgb2hsv - hsv", [h,s,v]);
    return [h,s,v];
  }

  /***********************************************************************************
  * Calculate HSV gradient from RGB values
  * @param c1 : initial color (in RGB, { r: xx, g: xx, b: xx} r,g & b integer between 0 and 255)
  * @param c2 : final color (in RGB, { r: xx, g: xx, b: xx} r,g & b integer between 0 and 255)
  ***********************************************************************************/
  quantumvizGts.hsvGradientFromRgbColors = function (c1, c2, steps) {
    // console.debug("[quantumviz-tools] hsvGradientFromRgbColors", {c1: c1, c2: c2, steps: steps});
    var c1hsv = quantumvizGts.rgb2hsv(c1.r,c1.g,c1.b);
    var c2hsv = quantumvizGts.rgb2hsv(c2.r,c2.g,c2.b);

    c1.h =c1hsv[0]; c1.s = c1hsv[1]; c1.v = c1hsv[2];
    c2.h =c2hsv[0]; c2.s = c2hsv[1]; c2.v = c2hsv[2];

    var gradient = quantumvizGts.hsvGradient(c1, c2, steps);
    for (var i in gradient) {
      gradient[i].rgb = quantumvizGts.hsv2rgb(gradient[i].h, gradient[i].s, gradient[i].v);
      gradient[i].r = Math.floor(gradient[i].rgb[0]);
      gradient[i].g = Math.floor(gradient[i].rgb[1]);
      gradient[i].b = Math.floor(gradient[i].rgb[2]);
    }
    console.debug("[quantumviz-tools] hsvGradientFromRgbColors", {c1: c1, c2: c2, steps: steps, gradient: gradient});
    return gradient;
  }

  /***********************************************************************************
  * Calculate HSV gradient
  * @param c1 : initial color (in HSV, { h: xx, s: xx, b: xx} h,s & b between 0 and 1)
  * @param c2 : final color (in HSV, { h: xx, s: xx, b: xx} h,s & b between 0 and 1)
  ***********************************************************************************/
  quantumvizGts.hsvGradient = function (c1, c2, steps) {
    // console.debug("[quantumviz-tools] hsvGradient", {c1: c1, c2: c2, steps: steps});
    var gradient = new Array(steps);

    // determine clockwise and counter-clockwise distance between hues
    var distCCW = (c1.h >= c2.h) ? c1.h - c2.h : 1 + c1.h - c2.h;
    distCW = (c1.h >= c2.h) ? 1 + c2.h - c1.h : c2.h - c1.h;

    // make gradient for this part
    for (var i = 0; i < steps; i ++) {
      // interpolate h, s, b
      var h = (distCW <= distCCW) ? c1.h + (distCW * i / (steps-1)) : c1.h - (distCCW * i / (steps-1));
      if (h < 0) {
        h = 1 + h
      }
      if (h > 1) {
        h = h - 1
      }
      var s = (1 - i / (steps-1)) * c1.s + i / (steps-1) * c2.s;
      var v = (1 - i / (steps-1)) * c1.v + i / (steps-1) * c2.v;
      // add to gradient array
      gradient[i] = {h:h, s:s, v:v};
    }
    return gradient;
  }

  /***********************************************************************************
  * Transforms quantumviz response object into nvd3 graphs objects
  ***********************************************************************************/
  quantumvizGts.toNvd3Graph = function(data) {

    if (!quantumvizGts.isValidResponse(data)) {
      return false;
    }

    var response = data[0];

    var chartData = {}

    var sparklines = [];
    for (var i=0; i< response.gts.length; i++) {
      // Let's verify if it's a GTS to plot
      if (gtsTools.isGtsToPlot(response.gts[i])) {
        var sl = quantumvizGts.gtsToNvd3(response.gts[i]);
        if (response.params[i].key !== undefined) {
          sl.key = response.params[i].key;
        }
        if (response.params[i].color !== undefined) {
          sl.color = response.params[i].color;
        }
        sl.area = false;
        if (response.params[i].interpolate !== undefined) {
          sl.interpolate = response.params[i].interpolate;
        } else {
          sl.interpolate = "step-before";
        }
        sparklines.push(sl);
      }
    }

    var tickFormat = function(d) {
      var dx = sparklines[0].values[d] && sparklines[0].values[d].x || 0;
      return dx ? d3.time.format('%x')(new Date(dx)) : '';
    }

    var globalParams = {}

    globalParams.interpolate = "step-before";

    if (response.globalParams !== undefined) {
      if (response.globalParams.interpolate !== undefined) {
        globalParams.interpolate = response.globalParams.interpolate;
      }
    }

    chartData.sparklines = sparklines;
    chartData.globalParams = globalParams;
    chartData.tickFormat = tickFormat;

    //console.debug("nvd3 data", chartData);
    //console.debug(JSON.stringify(chartData))

    return chartData;
  };


  /***********************************************************************************
  * Transforms quantumviz response object into annotation objects
  ***********************************************************************************/
  quantumvizGts.getAnnotations = function(data) {

    if (!quantumvizGts.isValidResponse(data)) {
      return false;
    }
    var response = data[0];

    if (!gtsTools.isArray(response.gts)) {
      return []
    }

    var annotations = [];

    for (var i=0; i< response.gts.length; i++) {
      // Let's verify if it's a GTS to plot
      if (gtsTools.isGtsToAnnotate(response.gts[i])) {
        var annotation = quantumvizGts.gtsToNvd3(response.gts[i]);
        if ((response.params !== undefined)
        && (response.params[i].key !== undefined)) {
          annotation.key = response.params[i].key;
        } else {
          annotation.key = annotation.c;
        }
        if ((response.params !== undefined)
        && (response.params[i].color !== undefined)) {
          annotation.color = response.params[i].color;
        } else {
          annotation.color = quantumvizGts.getColor(i);
        }
        annotations.push(annotation);
      }
    }

    return annotations;
  };


  quantumvizGts.extractCommonParameters = function(obj, params, index) {

    if (params.key !== undefined) {
      obj.key = params.key;
    }

    if (params.color !== undefined) {
      obj.color = params.color;
    } else {
      obj.color = quantumvizGts.getColor(index);
    }

    if (params.borderColor !== undefined) {
      obj.borderColor = params.borderColor;
    } else {
      obj.borderColor = "#000";
    }

    if (params.baseRadius === undefined || isNaN(parseInt(params.baseRadius)) || parseInt(params.baseRadius) < 0 ) {
      obj.baseRadius = quantumvizGts.BASE_RADIUS;
    } else {
      obj.baseRadius = params.baseRadius;
    }

  }


  /**
  * Transforms quantumviz response object into leaflet-map position array
  */
  quantumvizGts.toLeafletMapPositionArray = function(data) {

    if (!quantumvizGts.isValidResponse(data)) {
      return false;
    }

    var response = data[0];


    var positions = [];

    for (var i=0; i< response.gts.length; i++) {

      // console.debug("[quantumviz-tools] toLeafletMapPositionArray - response.gts[i]", response.gts[i])
      if (gtsTools.isPositionArray(response.gts[i])) {

        var posArray = response.gts[i];
        var params = response.params[i];

        quantumvizGts.extractCommonParameters(posArray, params, i);

        if (params.render !== undefined) {
          posArray.render = params.render;
        }

        if (posArray.render == 'weightedDots') {
          quantumvizGts.validateWeightedDotsPositionArray(posArray, params);
        }

        if (posArray.render == 'coloredWeightedDots') {
          quantumvizGts.validateWeightedColoredDotsPositionArray(posArray, params);
        }


        // console.debug("[quantumviz-tools] toLeafletMapPositionArray - posArray", posArray)
        positions.push(posArray);
      }
    }
    return positions;
  }

  quantumvizGts.validateWeightedColoredDotsPositionArray = function (posArray, params) {
    if (!quantumvizGts.validateWeightedDotsPositionArray(posArray, params)) {
      return;
    }

    if (params.minColorValue === undefined || params.maxColorValue === undefined || params.startColor === undefined || params.endColor === undefined) {
      console.error("[quantumviz-tools] validateWeightedColoredDotsPositionArray() - When using 'weightedColoredDots' rendering, 'maxColorValue', 'minColorValue', 'startColor' and 'endColor' parameters are compulsory");
      posArray.render = undefined;
      return;
    }

    posArray.maxColorValue = params.maxColorValue;
    posArray.minColorValue = params.minColorValue;
    params.startColor;
    params.endColor;

    if (typeof posArray.minColorValue != "number" || typeof posArray.maxColorValue != "number" || posArray.minColorValue >= posArray.maxColorValue  ) {
      console.error("[quantumviz-tools] validateWeightedColoredDotsPositionArray() - When using weightedColoredDots' rendering, 'maxColorValue' and 'minColorValue' must be numbers and 'maxColorValue' must be greater than 'minColorValue'", { maxColorValue: posArray.maxColorValue, minColorValue: posArray.minColorValue});
      posArray.render = undefined;
      return;
    }

    var re = /^#(?:[0-9a-f]{3}){1,2}$/i;

    if (typeof params.startColor != "string"
    || typeof params.endColor != "string"
    || !re.test(params.startColor)
    || !re.test(params.endColor) ){
      console.error("[quantumviz-tools] validateWeightedColoredDotsPositionArray() - When using weightedColoredDots' rendering, 'startColor' and 'endColor' parameters must be RGB colors in #rrggbb format", { startColor: params.startColor, endColor: params.endColor, tests: [typeof params.startColor, typeof params.endColor, re.test(params.startColor), re.test(params.endColor), re.test(params.startColor) ]});
      posArray.render = undefined;
      return;
    }

    posArray.startColor = {
      r: parseInt(params.startColor.substring(1,3),16),
      g: parseInt(params.startColor.substring(3,5),16),
      b: parseInt(params.startColor.substring(5,7),16)
    }

    posArray.endColor = {
      r: parseInt(params.endColor.substring(1,3),16),
      g: parseInt(params.endColor.substring(3,5),16),
      b: parseInt(params.endColor.substring(5,7),16)
    }

    if (params.numColorSteps === undefined || isNaN(parseInt(params.numColorSteps)) || parseInt(params.numColorSteps) < 0 ) {
      posArray.numColorSteps = 5;
    } else {
      posArray.numColorSteps = params.numColorSteps;
    }

    posArray.colorGradient = quantumvizGts.hsvGradientFromRgbColors(posArray.startColor, posArray.endColor,  posArray.numColorSteps);

    // console.debug("[quantumviz-tools] validateWeightedColoredDotsPositionArray", posArray);

    var step = (posArray.maxColorValue - posArray.minColorValue) / posArray.numColorSteps ;
    var steps = []
    for (var j = 0; j < posArray.numColorSteps; j++) {
      steps[j] = posArray.minColorValue + (j+1)*step;
    }

    posArray.steps = steps;

    for (var j in posArray.positions) {
      var colorValue = posArray.positions[j][3];
      posArray.positions[j][5] = posArray.numColorSteps -1;
      for (var k = 0; k< steps.length-1; k++) {
        if (colorValue < steps[k]) {
          var stepAssociatedToValue = k;
          posArray.positions[j][5] = stepAssociatedToValue;
          break;
        }
      }
      // console.debug("[quantumviz-tools] validateWeightedColoredDotsPositionArray", {j: j, position: posArray.positions[j], steps: steps, stepAssociatedToValue: stepAssociatedToValue})
    }

  }


  quantumvizGts.validateWeightedDotsPositionArray = function (posArray, params) {
    if (params.minValue === undefined || params.maxValue === undefined) {
      console.error("[quantumviz-tools] validateWeightedDotsPositionArray() - When using 'weightedDots' or 'weightedColoredDots' rendering, 'maxValue' and 'minValue' parameters are compulsory");
      posArray.render = undefined;
      return;
    }

    posArray.maxValue = params.maxValue;
    posArray.minValue = params.minValue;


    if (typeof posArray.minValue != "number" || typeof posArray.maxValue != "number" || posArray.minValue >= posArray.maxValue  ) {
      console.error("[quantumviz-tools] validateWeightedDotsPositionArray() - When using 'weightedDots' or 'weightedColoredDots' rendering, 'maxValue' and 'minValue' must be numbers and 'maxValue' must be greater than 'minValue'");
      posArray.render = undefined;
      return;
    }
    if (!gtsTools.isPositionsArrayWithValues(posArray) && !gtsTools.isPositionsArrayWithTwoValues(posArray)) {
      console.error("[quantumviz-tools] validateWeightedDotsPositionArray() - When using 'weightedDots' or 'weightedColoredDots' rendering, positions must have an associated value");
      posArray.render = undefined;
      return;
    }

    if (params.numSteps === undefined || isNaN(parseInt(params.numSteps)) || parseInt(params.numSteps) < 0 ) {
      posArray.numSteps = 5;
    } else {
      posArray.numSteps = params.numSteps;
    }
    var step = (posArray.maxValue - posArray.minValue) / posArray.numSteps;
    var steps = []
    for (var j = 0; j < posArray.numSteps-1; j++) {
      steps[j] = posArray.minValue+ (j+1)*step;
    }
    steps[posArray.numSteps-1] = posArray.maxValue;

    // console.debug("[quantumviz-tools] validateWeightedDotsPositionArray() - steps", steps)
    for (var j in posArray.positions) {
      var value = posArray.positions[j][2];
      posArray.positions[j][4] = posArray.numSteps-1;
      for (var k in steps) {
        if (value <= steps[k]) {
          var stepAssociatedToValue = k;
          posArray.positions[j][4] = stepAssociatedToValue;
          break;
        }
      }
    }
    return true;
  }

  /***********************************************************************************
  * Transforms annotations GTS from quantumviz response object into leaflet-map
  * positions arrays
  ***********************************************************************************/
  quantumvizGts.annotationsToLeafletPositions = function(data) {
    if (!quantumvizGts.isValidResponse(data)) {
      return false;
    }

    var response = data[0];

    var annotations = [];

    for (var i=0; i< response.gts.length; i++) {
      if (gtsTools.isGtsToAnnotate(response.gts[i])) {
        var annotation = {};
        var params = response.params[i];

        annotation.path = gtsTools.gtsToPath(response.gts[i]);

        quantumvizGts.extractCommonParameters(annotation, params, i);

        if (params.render !== undefined) {
          annotation.render = params.render;
        }

        if (annotation.render == 'marker') {

          if (params.marker) {
            annotation.marker = params.marker ;
          } else {
            annotation.marker = "circle";
          }
        }
        if (annotation.render == 'weightedDots') {
          quantumvizGts.validateWeightedDotsPositionArray(annotation, params);
        }


        annotations.push(annotation);
      }
    }
    // console.debug("[quantumviz-tools] annotationsToLeafletPositions", annotation)
    return annotations;

  }

  /***********************************************************************************
  * Transforms GTS from quantumviz response object into leaflet-map paths
  ***********************************************************************************/
  quantumvizGts.toLeafletMapPaths = function(data) {

    if (!quantumvizGts.isValidResponse(data)) {
      return false;
    }

    var response = data[0];

    var paths = [];

    for (var i=0; i< response.gts.length; i++) {

      if (gtsTools.isGtsToPlot(response.gts[i])) {
        var sl = {}

        sl.path = gtsTools.gtsToPath(response.gts[i]);

        if (response.params[i].key !== undefined) {
          sl.key = response.params[i].key;
        }

        if (response.params[i].color !== undefined) {
          sl.color = response.params[i].color;
        } else {
          sl.color = quantumvizGts.getColor(i);
        }

        // console.debug("[quantumviz-tools] toLeafletMapPaths - color", sl.color);
        paths.push(sl);
      }
    }
    //console.debug("Paths",paths);

    return paths;
  };

  /***********************************************************************************
  * Tranform a pathData @pathData into Leaflet path
  ***********************************************************************************/
  quantumvizGts.pathDataToLeaflet = function(pathData, options) {

    var path = [];

    var firstIndex = ((options === undefined) || (options.from === undefined) || (options.from < 0) )?0:options.from;
    var lastIndex =  ((options === undefined) || (options.to === undefined) || (options.to >= pathData.length) )?pathData.length-1:options.to;

    for (var i=firstIndex; i<= lastIndex; i++) {
      path.push([pathData[i].lat, pathData[i].lon]);
    }

    return path;
  };


  /***********************************************************************************
  * Gets the points array for the map bounds
  ***********************************************************************************/
  quantumvizGts.getBoundsArray = function(paths, positionsData) {
    var boundsArray = [];
    for (var i=0; i< paths.length; i++) {
      for (var j=0; j<paths[i].path.length; j++) {
        boundsArray.push([paths[i].path[j].lat,paths[i].path[j].lon])
      }
    }
    for (var i=0; i< positionsData.length; i++) {
      for (var j=0; j<positionsData[i].positions.length; j++) {
        boundsArray.push(positionsData[i].positions[j])
      }
    }
    return boundsArray;
  };





  /***********************************************************************************
  * Get time bounds for Nvd3 formatted GTS
  ***********************************************************************************/
  quantumvizGts.getTimeBounds = function(ndv3SeriesList) {

    var bounds = {}

    if (!gtsTools.isArray(ndv3SeriesList)) {
      console.error("[quantumvizGts.getTimeBounds] ndv3SeriesList isn't array",ndv3SeriesList);
      return bounds;
    }

    bounds.min = quantumvizGts.MAX_TS;
    bounds.max = quantumvizGts.MIN_TS;

    ndv3SeriesList.forEach(function(ndv3Series) {
      // console.debug("[quantumvizGts.getTimeBounds] Min:",ndv3Series.values[0].x)
      // console.debug("[quantumvizGts.getTimeBounds] Max: ", ndv3Series.values[ndv3Series.values.length - 1].x);
      if (bounds.min > ndv3Series.values[0].x) {
        bounds.min = ndv3Series.values[0].x;
      }
      if (bounds.max < ndv3Series.values[ndv3Series.values.length - 1].x) {
        bounds.max = ndv3Series.values[ndv3Series.values.length - 1].x;
      }
    });

    // console.debug("[quantumvizGts.getTimeBounds] bounds...", bounds);
    return bounds;
  }

  /***********************************************************************************
  * Tranform a gts @gts into nvd3 format
  ***********************************************************************************/
  quantumvizGts.gtsToNvd3 = function(gts) {
    var ndv3Series = {
      key: "",
      values: [],
      c: "",
      l: "",
      id: ""
    };
    ndv3Series.c = gts.c;
    ndv3Series.l = gts.l;
    ndv3Series.id = gts.id;
    ndv3Series.key = " " + gts.id + " - " + gts.c;
    if (gts.l != null) {
      ndv3Series.key += " - " + (JSON.stringify(gts.l));
    }

    if (gts.v !== undefined) {

      // Sort values
      gts.v = gts.v.sort(function(a, b) { return a[0] - b[0];});

      //console.debug(gts)
      for (var i = 0; i < gts.v.length; i++) {
        var metric = gts.v[i];
        ndv3Series.values.push({x: Math.round(metric[0] / 1000), y: metric[metric.length-1]});

        // ndv3Series.values.push({x: new Date(metric[0]/1000), y: metric[metric.length-1]});
      }
    }
    return ndv3Series;
  };


  /***********************************************************************************
  * Returns true if @data is a valid quantumviz response object
  ***********************************************************************************/
  quantumvizGts.isValidResponse = function(response) {

    if (!gtsTools.isArray(response) || (response.length != 1)) {
      console.error("Response isn't an Array or it has more than 1 element: ",response);
      return false;
    }
    response = response[0];

    if ((response.gts === undefined) || (response.params == undefined)) {
      console.error("Response hasn't gts and/or params components",response);
      return false;
    }

    if (!gtsTools.isArray(response.gts) || !gtsTools.isArray(response.params)) {
      console.error("Response's gts and/or params components aren't arrays",response);
      return false;
    }

    if (response.gts.length != response.params.length) {
      console.error("Response's gts and params components haven't the same length",response);
      return false;
    }

    if ((response.annotations !== undefined) && !gtsTools.isArray(response.annotations)) {
      console.error("Response's annotations component isn't an array");
      return false;
    }
    if ((response.annotationsParams !== undefined) && !gtsTools.isArray(response.annotationsParams)) {
      console.error("Response's annotationsParams component isn't an array");
      return false;
    }

    return true;
  };

  window.quantumvizGts = quantumvizGts;
}).call(this);
</script>
