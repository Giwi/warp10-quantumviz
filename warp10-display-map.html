<!--
@author Horacio Gonzalez (@lostinbrittany)
@copyright (c) 2016 Cityzen Data
@license Apache 2.0
-->
<link rel="import" href=" ../polymer/polymer.html">

<link rel="import" href="./quantumviz-external-deps.html">
<link rel="import" href="./warp10-display-map-tools.html">
<link rel="import" href="../leaflet-map/leaflet-map.html">

<dom-module id="warp10-display-map">
  <template>
    <style>
      :host {
        display: block;
        width: var(--default-width, 100%);
        height: var(--default-height, 100%);
        position: relative
      }

      #map {
        width: 100%;
        height: 100%;
      }
    </style>
    <leaflet-map
        id="map"
        latitude="{{latitude}}"
        longitude="{{longitude}}"
        zoom="{{zoom}}"
        on-load="_mapLoadedEvt"
        on-map-ready="_mapReadyEvt"
        on-resize="_mapResizeEvt"
        on-viewreset="_mapEvt"
        use-google-map="[[useGoogleMap]]"
        google-api-key="[[googleApiKey]]"
        fit-to-markers>
    </leaflet-map>
  </template>

</dom-module>

<script>
  // element registration
  Polymer({
        is: 'warp10-display-map',

        // Properties
        properties: {
          /**
           * The data of the map
           */
          data: {
            type: Object,
            notify: true,
            observer: '_dataChanged',
          },

          tiles: {
            type: Array,
            observer: '_dataChanged',
            value: [],
          },
          /**
           * The level of zoom
           */
          zoom: {
            type: Number,
            notify: true,
            value: 10,
          },
          /**
           * The longitude of the map center
           */
          longitude: {
            type: Number,
            notify: true,
          },
          /**
           * The latitude of the map center
           */
          latitude: {
            type: Number,
            notify: true,
          },
          /**
           * The selected value set
           */
          currentValues: {
            type: Object,
            observer: '_currentValuesChanged',
            notify: true,
          },
          /**
           * The timestamp of the selected annotationsSelectedTimestamp
           */
          annotationsSelectedTimestamp: {
            type: Number,
            notify: true,
            observer: '_annotationsSelectedTimestampChanged',
            value: -1,
          },
          /**
           * If true use Google maps instead of Open Street Map
           */
          useGoogleMap: {
            type: Boolean,
            value: false,
          },
          googleApiKey: {
            type: String,
          },
          /**
           * If true debug logs are sent to the console
           */
          debug: {
            type: Boolean,
            value: false,
          },
          _DEFAULT_WIDTH: {
            type: Number,
            value: 640,
          },
          _DEFAULT_HEIGHT: {
            type: Number,
            value: 480,
          },
        },


        // *************************************************************************
        // Livecycle
        // *************************************************************************

        created: function() {
          if (this.debug) {
            console.debug('[warp10-display-map] created');
          }

          // GTS paths
          this.polylinesBeforeCurrentValue = [];
          this.polylinesAfterCurrentValue = [];
          this.currentValuesMarkers = [];

          // GTS annotations
          this.annotationsMarkers = [];

          // PositionArrarys

          this.positionArraysMarkers = [];
        },

        ready: function() {
          if (this.debug) {
            console.debug('[warp10-display-map] ready');
          }
        },
        attached: function() {
          window.warp10DisplayMapTools.debug = this.debug;
          if (this.debug) {
            console.debug('[warp10-display-map] attached');
          }
          this.configure();
          this.isAttached = true;
          if (this.data !== null) {
            this._dataChanged();
          }
        },


        // *************************************************************************
        // Observers
        // *************************************************************************

        _dataChanged: function() {
          if (!this.isAttached || !this.mapLoaded) {
            // Component not ready yet
            return;
          }
          if (this.data !== null) {
            this._updateMapData();
          } else {
            this._removeMapData();
          }
        },
        _annotationsSelectedTimestampChanged: function() {
          if (this.debug) {
            console.debug('[warp10-display-map] _annotationsSelectedTimestampChanged', this.annotationsSelectedTimestamp);
          }
          for (var i = 0; i < this.annotationsMarkers.length; i++) {
            for (var tick = 0; tick < this.annotationsMarkers[i].length; tick++) {
              if (this.debug) {
                console.debug('[warp10-display-map] _annotationsSelectedTimestampChanged - this.annotationsMarkers[i][tick].options.timestamp', this.annotationsMarkers[i][tick].options.timestamp);
              }
              // We divide by 10 because d3.x precision problem
              if (Math.floor(this.annotationsMarkers[i][tick].options.timestamp / 10) === Math.floor(this.annotationsSelectedTimestamp / 10)) {
                if (this.debug) {
                  console.debug('[warp10-display-map] _annotationsSelectedTimestampChanged - found', this.annotationsMarkers[i][tick]);
                }
                this.annotationsMarkers[i][tick].options.oldStyle = this.annotationsMarkers[i][tick].options.fillColor;
                this.annotationsMarkers[i][tick].setStyle({fillColor: 'orange'});
              } else {
                if (this.annotationsMarkers[i][tick].options.oldStyle) {
                  this.annotationsMarkers[i][tick].setStyle({
                    fillColor: this.annotationsMarkers[i][tick].options.oldStyle,
                  });
                  this.annotationsMarkers[i][tick].options.oldStyle = null;
                }
              }
            }
          }
        },
        _currentValuesChanged: function() {
          if (!this.currentValues) return;
          // All works on seconds only now...
          if (this.debug) {
            console.log("[warp10-display-map] _currentValuesChanged - Current time " + this.currentValues.xValue + " - " + new Date(this.currentValues.xValue) + " - " + (new Date(this.currentValues.xValue)).getTime());
          }
          var currentTS = Math.floor((new Date(this.currentValues.xValue)).getTime() / 1000);
          this.pathData = this.pathData || [];
          for (var i = 0; i < this.pathData.length; i++) {
            for (var j = 0; j < this.pathData[i].path.length; j++) {
              if (this.debug) {
                console.log("[warp10-display-map] _currentValuesChanged - Do they match? " + currentTS + " - " + this.pathData[i].path[j].ts);
              }
              if (currentTS <= Math.floor(this.pathData[i].path[j].ts / 1000)) {
                this.currentValuesMarkers[i].setLatLng([this.pathData[i].path[j].lat, this.pathData[i].path[j].lon]);
                this.polylinesBeforeCurrentValue[i].setLatLngs(warp10DisplayMapTools.pathDataToLeaflet(this.pathData[i].path, {to: j}));
                this.polylinesAfterCurrentValue[i].setLatLngs(warp10DisplayMapTools.pathDataToLeaflet(this.pathData[i].path, {from: j}));
                break;
              }
            }
          }
        },

        // *************************************************************************
        // Event listeners
        // *************************************************************************

        _mapLoadedEvt: function() {
          if (this.debug) {
            console.debug('[warp10-display-map] Map loaded!', {
              obj: this.$.map,
              map: this.$.map.map,
              longitude: this.$.map.longitude,
              latitude: this.$.map.latitude,
              zoom: this.$.map.zoom,
            });
          }
          this.mapLoaded = true;
          if (this.data !== null) {
            this._dataChanged();
          }
        },

        _mapReadyEvt: function() {
          if (this.debug) {
            console.debug('[warp10-display-map] Map ready!', {
              obj: this.$.map,
              map: this.$.map.map,
              longitude: this.$.map.longitude,
              latitude: this.$.map.latitude,
              zoom: this.$.map.zoom,
            });
          }
          this.mapReady = true;
          if (this.data !== null) {
            this._dataChanged();
          }
        },

        _mapResizeEvt: function() {
          if (this.debug) {
            console.debug('[warp10-display-map] Map resize!', {
              obj: this.$.map,
              map: this.$.map.map,
              longitude: this.$.map.longitude,
              latitude: this.$.map.latitude,
              zoom: this.$.map.zoom,
            });
          }
        },

        _mapEvt: function(evt) {
          if (this.debug) {
            console.debug('[warp10-display-map] Map evt!', evt, {
              obj: this.$.map,
              map: this.$.map.map,
              longitude: this.$.map.longitude,
              latitude: this.$.map.latitude,
              zoom: this.$.map.zoom,
            });
          }
        },


        // *************************************************************************
        // Instance methods
        // *************************************************************************

        configure: function() {
          if (this.debug) {
            console.debug('[warp10-display-map] configure'); // Dimensions
          }

          if (this.debug) {
            console.debug("[warp10-display-map] configure", this.clientWidth, this.clientHeight);
            console.debug("[warp10-display-map] configure", this._DEFAULT_WIDTH, this._DEFAULT_HEIGHT);
          }
          // Dimensions
          if (this.clientWidth === 0) {
            this.updateStyles({'--default-width': this._DEFAULT_WIDTH + 'px'});
          }
          if (this.clientHeight === 0) {
            this.updateStyles({'--default-height': this._DEFAULT_HEIGHT + 'px'});
          }

          if (this.debug) {
            console.debug('[warp10-display-map] configure', this.clientWidth, this.clientHeight);
            console.debug('[warp10-display-map] configure', this.$.map.clientWidth, this.$.map.clientHeight);
            console.debug('[warp10-display-map] Dimensions', this.$.map.style);
          }
        },

        _updateMapData: function() {
          if (this.debug) {
            console.debug('[warp10-display-map] _updateMapData', this.data);
          }

          if (this.layerGroup) {
            this._removeMapData();
          }

          this.pathData = warp10DisplayMapTools.toLeafletMapPaths(this.data);
          this.annotationsData = warp10DisplayMapTools.annotationsToLeafletPositions(this.data);
          this.positionData = warp10DisplayMapTools.toLeafletMapPositionArray(this.data);
          if (this.debug) {
            console.debug('[warp10-display-map] Data changed - path data', this.pathData);
            console.debug('[warp10-display-map] Data changed - position arrays', this.positionData);
            console.debug('[warp10-display-map] Data changed - annotations data', this.annotationsData);
          }

          var map = this.$.map.map;

          this.layerGroup = L.layerGroup().addTo(map);

          if (this.debug) {
            console.debug('[warp10-display-map] Data changed - map', this.$.map);
          }


          var circleRadius = map.getBounds().getSouthWest().distanceTo(map.getBounds().getNorthEast()) / 30;
          // Create the polylines and the circle marker
          for (var i = 0; i < this.pathData.length; i++) {
            var plottedGts = this._updateGtsPath(this.pathData[i]);
            this.polylinesBeforeCurrentValue.push(plottedGts.beforeCurrentValue);
            this.polylinesAfterCurrentValue.push(plottedGts.afterCurrentValue);
            this.currentValuesMarkers.push(plottedGts.currentValue);
          }

          if (this.debug) {
            console.debug('[warp10-display-map] GTS path added', this.pathData);
          }

          for (var i = 0; i < this.annotationsData.length; i++) {
            this.annotationsMarkers.push(this._updateAnnotation(this.annotationsData[i]));
          }
          if (this.debug) {
            console.debug('[warp10-display-map] Annotations added', this.annotationsMarkers);
          }

          // Create the positions arrays
          for (var i = 0; i < this.positionData.length; i++) {
            this.positionArraysMarkers = this._updatePositionArray(this.positionData[i]);
          }
          if (this.debug) {
            console.debug('[warp10-display-map] Position array added', this.positionArraysMarkers);
          }

          this.tiles.forEach(function(t) {
            console.log('Adding tiles : ', t);
            this.addLayer(L.tileLayer(t));
          }, this.layerGroup);

          if (this.pathData.length > 0 || this.positionData.length > 0 || this.annotationsData.length > 0) {
            // Fit map to curves
            map.invalidateSize();
            var bounds = warp10DisplayMapTools.getBoundsArray(this.pathData, this.positionData, this.annotationsData);

            if (this.debug) {
              console.debug('[warp10-display-map] getBoundsArray', bounds);
            }
            if (bounds.length > 1) {
              map.fitBounds(bounds, {padding: [20, 20]});
              if (this.zoom < map.getZoom()) {
                map.setZoom(this.zoom);
              }
            } else {
              map.setView(bounds[0], this.zoom);
            }
          }
          this.layerGroup.addLayer(L.tileLayer('http://tiles-{s}.cityzendata.net/@paris%2Fmacro-custom-gmao/\\\'cause\\\'/\'ALL\'/\'ALL\'/\'0026\'/\'C013\'/2/10/{z}/{x}/{y}'));
        },

        _updateGtsPath: function(gts) {
          var beforeCurrentValue =
              L.polyline(
                  warp10DisplayMapTools.pathDataToLeaflet(gts.path, {to: 0}), {
                    color: gts.color,
                    opacity: 1,
                  });
          this.layerGroup.addLayer(beforeCurrentValue);
          var afterCurrentValue = L.polyline(
              warp10DisplayMapTools.pathDataToLeaflet(gts.path, {from: 0}), {
                color: gts.color,
                opacity: 0.5,
              });
          this.layerGroup.addLayer(afterCurrentValue);
          var currentValue;
          // Let's verify we have a path... No path, no marker
          if (gts.path[0] !== undefined) {
            currentValue = L.circleMarker([gts.path[0].lat, gts.path[0].lon],
                {radius: 5, color: '#fff', fillColor: gts.color, fillOpacity: 1});
          } else {
            currentValue = L.circleMarker();
          }
          this.layerGroup.addLayer(currentValue);
          return {
            beforeCurrentValue: beforeCurrentValue,
            afterCurrentValue: afterCurrentValue,
            currentValue: currentValue,
          };
        },

        _updateAnnotation: function(gts) {
          var positions = [];

          switch (gts.render) {
            case 'marker':
              var icon = L.MakiMarkers.icon({icon: gts.marker, color: gts.color, size: 'm'});
              for (var j = 0; j < gts.path.length; j++) {
                var marker = L.marker(gts.path[j], {icon: icon, opacity: 1});
                marker.bindPopup(gts.path[j].val.toString());
                this.layerGroup.addLayer(marker);
                positions.push(marker);
              }
              break;
            case 'dots':
            default:
              for (var j = 0; j < gts.path.length; j++) {
                var marker = L.circleMarker(
                    gts.path[j], {
                      radius: gts.baseRadius,
                      color: gts.color,
                      fillColor: gts.color,
                      fillOpacity: 1,
                      timestamp: gts.path[j].ts,
                    }
                );
                marker.bindPopup(gts.path[j].val.toString());
                this.layerGroup.addLayer(marker);
                if (this.debug) {
                  console.debug('[warp10-display-map] _plotAnnotation - gts', gts);
                }
                positions.push(marker);
              }
              break;
          }
          return positions;
        },

        _updatePositionArray: function(positionData) {
          if (this.debug) {
            console.debug('[warp10-display-map] _plotPositionArray - item', positionData);
          }
          var positions = [];
          switch (positionData.render) {
            case 'path':
              var polyline = L.polyline(positionData.positions, {color: positionData.color, opacity: 1});
              this.layerGroup.addLayer(polyline);
              positions.push(polyline);
              break;
            case 'marker':
              var icon = L.MakiMarkers.icon({icon: positionData.key, color: positionData.color, size: 'm'});
              for (var j = 0; j < positionData.positions.length; j++) {
                var marker = L.marker({lat: positionData.positions[j][0], lon: positionData.positions[j][1]}, {
                  icon: icon,
                  opacity: 1,
                });
                this.layerGroup.addLayer(marker);
                positions.push(marker);
              }
              break;
            case 'coloredWeightedDots':
              var result = [];
              var inStep = [];
              for (var j = 0; j < positionData.numColorSteps; j++) {
                result[j] = 0;
                inStep[j] = 0;
              }
              for (var j = 0; j < positionData.positions.length; j++) {
                if (this.debug) {
                  console.debug('[warp10-display-map] _plotPositionArray, coloredWeightedDots', {
                    j: j,
                    gradient: positionData.colorGradient,
                    position: positionData.positions[j],
                  });
                }
                var marker = L.circleMarker(
                    {lat: positionData.positions[j][0], lon: positionData.positions[j][1]}, {
                      radius: positionData.baseRadius * (parseInt(positionData.positions[j][4]) + 1),
                      color: positionData.borderColor,
                      fillColor: warp10ColorTools.rgb2hex(
                          positionData.colorGradient[positionData.positions[j][5]].r,
                          positionData.colorGradient[positionData.positions[j][5]].g,
                          positionData.colorGradient[positionData.positions[j][5]].b),
                      fillOpacity: 1,
                    });
                this.layerGroup.addLayer(marker);
                positions.push(marker);
              }
              break;
            case 'weightedDots':
              for (var j = 0; j < positionData.positions.length; j++) {
                var marker = L.circleMarker(
                    {lat: positionData.positions[j][0], lon: positionData.positions[j][1]}, {
                      radius: positionData.baseRadius * (parseInt(positionData.positions[j][4]) + 1),
                      color: positionData.borderColor,
                      fillColor: positionData.color, fillOpacity: 1,
                    });
                this.layerGroup.addLayer(marker);
                positions.push(marker);
              }
              break;
            case 'dots':
            default:
              for (var j = 0; j < positionData.positions.length; j++) {
                var marker = L.circleMarker(
                    {lat: positionData.positions[j][0], lon: positionData.positions[j][1]}, {
                      radius: positionData.baseRadius,
                      color: positionData.borderColor,
                      fillColor: positionData.color,
                      fillOpacity: 1,
                    });
                this.layerGroup.addLayer(marker);
                positions.push(marker);
              }
              break;
          }
          return positions;
        },

        _removeMapData: function() {
          var map = this.$.map.map;
          map.removeLayer(this.layerGroup);
        },
      }
  );
</script>
